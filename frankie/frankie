#!/store/anaconda/anaconda/bin/python3.5

import os
import re
import sys
import fire
import requests
import unidecode
from lxml import etree
from lxml import html
import lxml

template = """
{
  "frankie_config_version": 0.1,
  "website": "http://your.website.here/",
  "pipelines": [
      {
        "name": "default",
        "intercept": "^/$",
        "edits": [
           {
             "name": "HelloWorld",
             "type": "simple",
             "find": "World",
             "replace": "Frankie"
           }
        ]
      }
  ]
}
    
"""

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

def _htmlParse(html):
    parser = etree.HTMLParser(encoding='utf-8')
    tree   = etree.parse(StringIO(html), parser)
    return tree

def _fix_absolute_links(base_url, frankie_url, doc):
    doc = re.sub(base_url, '//' + frankie_url, doc)

    return doc

def _XPathRemove(doc, xpath):
    parsedDoc = _htmlParse(doc)
    element = parsedDoc.find(xpath)
    if element is None:
       return doc

    element.clear()
    doc = etree.tostring(parsedDoc, pretty_print=True, method="html")
    return doc.decode("utf-8")

def _XPathSetText(doc, XPathFind, text):
    parsedDoc = _htmlParse(doc)
    element = parsedDoc.find(XPathFind)
    if element is not None:
        element.clear()

        fragments = html.fragments_fromstring(text)
        last = None

        for frag in fragments:
          if isinstance(frag, lxml.etree._Element):
            element.append(frag)
            last = frag
          else:
            if last:
              last.tail = frag
            else:
              element.text = frag


        doc = etree.tostring(parsedDoc, pretty_print=True, method="html")
        return doc.decode("utf-8")
    else:
        return doc
     

def _XPathReplace(doc, XPathFind, replace): 
    parsedDoc = _htmlParse(doc)
    element = parsedDoc.find(XPathFind)
    if element is not None:
        element.clear()
        element.append(etree.fromstring(replace))
        doc = etree.tostring(parsedDoc, pretty_print=True, method="html")
        return doc.decode("utf-8")
    else:
        return doc

def _XPathCopyFromRemote(doc, origin, XPathSource, XPathDest, attribute = None):
    parsedDoc = _htmlParse(doc)
    sourceDoc = _htmlParse(requests.get(origin).text)
    element = sourceDoc.find(XPathSource)
    elementDest = parsedDoc.find(XPathDest)
    elementDest.clear()
    if attribute is not None:
       if attribute == 'text()':
          elementDest.text = element.text
       else:
          elementDest.set(attribute, element.get(atttribute))
    else:
        elementDest.append(element)
    doc = etree.tostring(parsedDoc, pretty_print=True, method="html")
    return doc.decode("utf-8")
     

def _injectJS(doc, url):
    parsedDoc = _htmlParse(doc)
    element = parsedDoc.find('//head')
    element.insert(0, etree.fromstring('<script src="' + url + '"></script>'))
    doc = etree.tostring(parsedDoc, pretty_print=True, method="html")
    return doc.decode("utf-8")

def _loadPipelines(config_file, filename):
    if 'pipelines' not in config_file:
       print('no pipelines found in ' + filename)
       return
    
    result = {}

    for pipeline in config_file['pipelines']:
        result[pipeline['name']] = pipeline

    return result

    

    

def run(config = 'config.js'):
    import json
    import requests
    from lxml import etree
    from flask import Flask
    from flask import request
    from flask import Response

    proxy = Flask(__name__)

    try:
        with open(config) as f:
            config_file = json.loads(f.read())
    except FileNotFoundError as e:
        print('Unable to find \'' + config + '\'.')
        print('Please specify config file using --config') 
        sys.exit(-1)

    @proxy.route('/', defaults={'path': ''})
    @proxy.route('/<path:path>', methods=['GET', 'POST'])
    def _handle(path):
  
        path = '/' + path

        params = re.sub('http.?://' + request.host + '/', '/', request.url)

        if params is not None and params != [] and params[0] == '/' and path != '/':
            parts = config_file['website'].split('/') 
            url = parts[0] + '//' + parts[2]  + params
        else: 
            url = config_file['website'] + params

        print('new url ' + url)

        # TODO propagate headers 
        headers = {}

        for header in request.headers:
            if header[0] not in ['Host', 'Referer', 'Cookie']:
               headers[header[0]] = header[1]

 
        if request.method == 'GET':
            rsp = requests.get(url, headers = headers)
        else:
            rsp = requests.post(url, headers = headers)


        doc = rsp.text

        doc = _fix_absolute_links(config_file['website'], request.host + '/', doc)

        pipelines = _loadPipelines(config_file, config)

        if pipelines is None:
           return doc

        pipeline = pipelines['default']

        intercepts = pipeline['intercept'].split(',')

        should_filter = None

        for intercept in intercepts:
            if should_filter is None:
                should_filter = re.search(intercept, re.sub('http.?://' + request.host, '', request.url)) is not None
            else:
                should_filter = should_filter or (re.search(intercept, re.sub('http.?://' + request.host, '', request.url)) is not None)

        if should_filter:
            for patch in pipeline['edits']:
                print('applying ' + patch['name'])
                if patch['type'] == 'simple':
                    doc = re.sub(patch['find'], patch['replace'], doc, re.MULTILINE)

                elif patch['type'] == 'XPathRemove':
                    doc = _XPathRemove(doc, patch['xpath'])

                elif patch['type'] == 'XPathReplace':
                    doc = _XPathReplace(doc, patch['find'], patch['replace'])
 
                elif patch['type'] == 'XPathSetText':
                    doc = _XPathSetText(doc, patch['find'], text = patch['text'])

                elif patch['type'] == 'InjectJS':
                    doc = _injectJS(doc, patch['url'])

                elif patch['type'] == 'ActivateVueJS':
                    vueSrc = "<script>var app = new Vue({el: '#" + patch['el'] + "'});</script>"
                    doc = re.sub('</body>', vueSrc + "</body>", doc)

                elif patch['type'] == 'XPathCopyFromRemote':
                    doc = _XPathCopyFromRemote(doc, patch['origin'], patch['XPathSource'], patch['XPathDest'], patch['attribute'])

                elif patch['type'] == 'StaticSnippetInject':
                    name = unidecode.unidecode(patch['name'])
                    name = re.sub(' ', '-', name)
                    path = os.path.abspath('snippets') + '/' + name

                    if not os.path.exists(path):
                        os.makedirs(path)

                    subdirs = ['html', 'css', 'js']
                
                    for subdir in subdirs: 
                        if not os.path.exists(path + '/' + subdir):
                            os.makedirs(path + '/' + subdir)

                else:
                    print('Edit "' + patch['type'] + ' not defined.')
                    sys.exit(-1)
 
        frankieResponse = Response(doc)
        
        for header in rsp.headers:
           if header != 'Transfer-Encoding' and header != 'Content-Length' and header != 'Content-Encoding' and header != 'P3P':
               frankieResponse.headers[header] = rsp.headers.get(header) #headers = response.headers

        return frankieResponse

    proxy.run() 

def new(path):
    if os.path.isdir(path):
       print(path + " already exists.")
       return

    print("creating \"" + path + "\"")
    os.makedirs(path)

    path = os.path.abspath(path)

    with open(path + '/config.js', 'w') as config:
        config.write(template)
       

def main():
    app = fire.Fire() 

if __name__ == "__main__":
    main()

